}
# find the root (i.e. 1/(1+y))
func = function(x) {
y = -100 + 5*x + 5*x^(2) +5*x^(3) +5*x^(4) +105*x^(5)
return(y)
}
bisection(func,0.2,1.1)
#find the new y
func2 = function(x) {
y = -100 + 4*x + 4.25*x^(2) +4.5*x^(3) +4.75*x^(4) +105*x^(5)
return(y)
}
bisection(func2,0.2,1.1)
#B1
func0 = function(x){
y = 6/(1+x)+6/(1+x)^2+6/(1+x)^3+6/(1+x)^4+6/(1+x)^5+6/(1+x)^6+6/(1+x)^7+6/(1+x)^8+6/(1+x)^9+106/(1+x)^10
return(y)
}
x = seq(0,0.1,0.002)
x2 = c(0.04, 0.0401)
s = (func0(x2[1])-func0(x2[2]))/(x2[1]-x2[2]) #slope of tangent
plot(x,func0(x),type = "l", ylab = "bond price($)", xlab = "yield to maturity in years")
lines(c(0.04,0.06),c(func0(0.06),func0(0.06)), type="l", col="blue", lwd=2, pch=19)
lines(c(0.04,0.04),c(func0(0.04),func0(0.06)), type="l", col="blue", lwd=2, pch=19)
lines(c(0.04,0.06),c(func0(0.04),func0(0.06)), type="l", col="blue", lwd=2, pch=19)
plot(x,func0(x),type = "l", ylab = "bond price($)", xlab = "yield to maturity in years")
abline(func0(x2[1])-x2[1]*s,s, col = "red")
points(0.04,func0(0.04),col="blue")
#--------------------------
#B2
#Bisection method:
bisection <- function (f, a, b, tol = 1e-7)
{
if ((f(a) > 0) && (f(b) > 0)) {
stop('same signs')
} else if ((f(a) < 0) && (f(b) < 0)) {
stop('same signs')
} else if (f(a)==0) {
return(a)
} else if (f(b)==0) {
return(b)
}
for (i in 1:10000) {
c = (a + b) / 2
if (f(a)*f(c)>0) {
a = c
} else if
(f(b)*f(c)>0) {
b = c
}
if ((f(c) == 0) || (abs(b-a)) < tol) {
return(c)
}
}
print("notfind")
}
# find the root (i.e. 1/(1+y))
func = function(x) {
y = -100 + 5*x + 5*x^(2) +5*x^(3) +5*x^(4) +105*x^(5)
return(y)
}
bisection(func,0.2,1.3)
#find the new y
func2 = function(x) {
y = -100 + 4*x + 4.25*x^(2) +4.5*x^(3) +4.75*x^(4) +105*x^(5)
return(y)
}
bisection(func2,0.2,1.3)
#B1
func0 = function(x){
y = 6/(1+x)+6/(1+x)^2+6/(1+x)^3+6/(1+x)^4+6/(1+x)^5+6/(1+x)^6+6/(1+x)^7+6/(1+x)^8+6/(1+x)^9+106/(1+x)^10
return(y)
}
x = seq(0,0.1,0.002)
x2 = c(0.04, 0.0401)
s = (func0(x2[1])-func0(x2[2]))/(x2[1]-x2[2]) #slope of tangent
plot(x,func0(x),type = "l", ylab = "bond price($)", xlab = "yield to maturity in years")
lines(c(0.04,0.06),c(func0(0.06),func0(0.06)), type="l", col="blue", lwd=2, pch=19)
lines(c(0.04,0.04),c(func0(0.04),func0(0.06)), type="l", col="blue", lwd=2, pch=19)
lines(c(0.04,0.06),c(func0(0.04),func0(0.06)), type="l", col="blue", lwd=2, pch=19)
plot(x,func0(x),type = "l", ylab = "bond price($)", xlab = "yield to maturity in years")
abline(func0(x2[1])-x2[1]*s,s, col = "red")
points(0.04,func0(0.04),col="blue")
#--------------------------
#B2
#Bisection method:
bisection <- function (f, a, b, tol = 1e-7)
{
if ((f(a) > 0) && (f(b) > 0)) {
stop('same signs')
} else if ((f(a) < 0) && (f(b) < 0)) {
stop('same signs')
} else if (f(a)==0) {
return(a)
} else if (f(b)==0) {
return(b)
}
for (i in 1:10000) {
c = (a + b) / 2
if (f(a)*f(c)>0) {
a = c
} else if
(f(b)*f(c)>0) {
b = c
}
if ((f(c) == 0) || (abs(b-a)) < tol) {
return(c)
}
}
print("notfind")
}
# find the root (i.e. 1/(1+y))
func = function(x) {
y = -100 + 5*x + 5*x^(2) +5*x^(3) +5*x^(4) +105*x^(5)
return(y)
}
bisection(func,0.2,1.1)
#find the new y
func2 = function(x) {
y = -100 + 4*x + 4.25*x^(2) +4.5*x^(3) +4.75*x^(4) +105*x^(5)
return(y)
}
bisection(func2,0.2,1.1)
# Let it be a 10-year bond, 6% coupon with annual coupon payment.
# Left hand side = p(y)-p(y+delta y). let delta y = 0.001
fy<-function(y){(6*(1-1/(1+y)^10))/y-6*(1-1/(1+y+0.001)^10)/(y+0.001)}
curve(expr=fy,from=0,to=1)
# Right hand side = -D(delta y)
fy1<-function(y){0.001*(10*y/(1+y)^11+1-1/(1+y)^10)/y^2}
curve(expr=fx1,from=0,to=1,add=TRUE)
# Let it be a 10-year bond, 6% coupon with annual coupon payment.
# Left hand side = p(y)-p(y+delta y). let delta y = 0.001
fy<-function(y){(6*(1-1/(1+y)^10))/y-6*(1-1/(1+y+0.001)^10)/(y+0.001)}
curve(expr=fy,from=0,to=1)
# Right hand side = -D(delta y)
fy1<-function(y){0.001*(10*y/(1+y)^11+1-1/(1+y)^10)/y^2}
curve(expr=fy1,from=0,to=1,add=TRUE)
# Let it be a 10-year bond, 6% coupon with annual coupon payment.
# Left hand side = p(y+delta y). let delta y = 0.001
fy<-function(y){6*(1-1/(1+y+0.001)^10)/(y+0.001)}
curve(expr=fy,from=0,to=1)
# Right hand side = P(y){1-D*(delta y)}
fy1<-function(y){(6*(1-1/(1+y)^10))/y+0.001*(10*y/(1+y)^11+1-1/(1+y)^10)/y^2}
curve(expr=fy1,from=0,to=1,add=TRUE)
# let t = 1/(1+y)
ft = function(t){5*t+5*t^2+5*t^3+5*t^4+105*t^5-100.1580}
ft1 = function(t){5+10*t+15*t^2+20*t^3+525*t^4}
# we choose the starting y = 1 ---> t = 0.5
t = 0.5
while (abs(ft(t))>0.0000000001){t=t-ft(t)/ft1(t)}
# we can have y = 1/t - 1
1/t-1
pv<-5/(1+0.04)+5/(1+0.0425)^2+5/(1+0.0475)^3+5/(1+0.049)^4+105/(1+0.05)^5
fy<-function(y){
5/(1+y)+5/(1+y)^2+5/(1+y)^3+5/(1+y)^4+105/(1+y)^5-pv
}
curve(fy,xlim=c(0,0.1),col='red',lty=2)
abline(h=0)
bisection<-function(fy,a,b,n=1000,tol=1e-7){
if(!fy(a)*fy(b)<0){
stop('signs of fy(a) and fy(b) are different')
}
for (i in 1:n){
c<-(a+b)/2
if((fy(c)==0)||((b-a)/2)<tol){
return(c)
}
ifelse(sign(fy(c))==sign(fy(a)),
a<-c,
b<-c)
}
}
print(bisection(fy,0.04,0.06))
# Create cash flow vector
cf <- c(-100.16, 5, 5, 5, 5, 105)
# Create bond valuation function
bval <- function(i, cf,
t=seq(along = cf))
sum(cf / (1 + i)^t)
# Create ytm() function using uniroot
ytm <- function(cf) {
uniroot(bval, c(0, 1), cf = cf)$root
}
#1a
#f,n,x,s need to be initialized
TaylorDiff<-function(f,n,x,s) {
k<-D(as.expression(body(f)),'x')
p<-f(x)
for (j in 1:n) {
p<-p+eval(k,list(x))*s^(j)*(1/factorial(j))
k<-D(k,"x")
}
return(p-f(x+s))
}
#1b	example of sin(x) approximated at x0=1
f<-function(x) sin(x)
x0<-1
k<-D(as.expression(body(f)),'x')
k2<-D(k,'x')
plot(f,xlim=c(-5,5),ylim=c(-5,5),type='l',col='red')
app1<-function(x) f(x0)+eval(k,list(x=x0))*(x-x0)
app2<-function(x) app1(x)+0.5*eval(k2,list(x=x0))*(x-x0)^2
plot(app1,xlim=c(-5,5),ylim=c(-5,5),type='l',col='blue',add=T)
plot(app2,xlim=c(-5,5),ylim=c(-5,5),type='l',col='violet',add=T)
f<-function(x) 5/x*(1-1/(1+x)^5)+100/(1+x)^5-100.158
plot(f,type='l',col='red')
#bisection
bisection<-function(f,a,b,n=1000,err=0.000001) {
if(f(a)*f(b)>0)
stop('signs of f(a) and f(b) are same')
else {
for (i in 1:n) {
c<-(a+b)/2
if(f(c)==0||(b-a)<err)
return(c)
else if(f(c)*f(a)>0)
a<-c
else
b<-c
}
print('too many times!')
}
}
bisection(f,0.001,1)
#newton
k<-D(as.expression(body(f)),'x')
x0<-0.3
x<-x0
for(j in 1:1000) {
x<-x-f(x)/eval(k,list(x))
}
print(x)
# RMSC2001 Assignment 2
# Li Keqi
# 1155107825
# X1.a
approximate<-function(func,x,change){
return (eval(D(func,"x"))*change+(eval(D(D(func,"x"),"x"))*change^2)/2+(eval(D(D(D(func,"x"),"x"),"x"))*change^3)/6)
}
# X1.b
# It's just the Taylor series using only the first derivative, so we can use this approximation.
# Now we plot the figure
# First, suppose this is the P(x). x is the yield
fx <- expression(10/(1+x)^1+10/(1+x)^2+10/(1+x)^3+10/(1+x)^4+10/(1+x)^5+1010/(1+x)^6)
x<- seq(0.01,1,by=0.0001)
plot(x, eval(fx),type="l")
x<-0.5
P<-eval(fx)
x<- seq(0.01,1,by=0.0001)
y<-rep(0.5, length(x))
change<-seq(-0.49,0.5,by=0.0001)
lines(x,P+approximate(fx,y,change),col="red")
# X2.a
(price <- 5/(1+0.04)^1 + 5/(1+0.0425)^2 + 5/(1+0.0475)^3 + 5/(1+0.049)^4 + 105/(1+0.05)^5)
fy <- function(y){
price -( 5/(1+y)^1 + 5/(1+y)^2 + 5/(1+y)^3 + 5/(1+y)^4 + 105/(1+y)^5)
}
fy2 <- function(y){
(fy(y))^2
}
# To get the solution, we only need to optimize the function fy2
optimize(fy2,c(0.000001,1))$minimum
# Therefore, the yield is 0.04963675
# And we could check it by ploting it
plot(fy,xlim = c(0,1),ylim = c(-20,80))
abline(h = 0)
abline(v = optimize(fy2,c(0.000001,1))$minimum)
# X2.b
# First, calculate the new price
(price <- 5/(1+0.0425)^1 + 5/(1+0.045)^2 + 5/(1+0.05)^3 + 5/(1+0.0515)^4 + 105/(1+0.0525)^5)
# The new price should be 99.08189
optimize(fy2,c(0.000001,1))$minimum
# The new YTM is 0.05211581
approximate(expression(5/(1+x)^1 + 5/(1+x)^2 + 5/(1+x)^3 + 5/(1+x)^4 + 105/(1+x)^5), 0.04963675, 0.05211581 - 0.04963675)
# The unrealised profit/loss is  -1.068128
# RMSC2001 Assignment 2
# Li Keqi
# 1155107825
# X1.a
approximate<-function(func,x,change){
return (eval(D(func,"x"))*change+(eval(D(D(func,"x"),"x"))*change^2)/2+(eval(D(D(D(func,"x"),"x"),"x"))*change^3)/6)
}
# X1.b
# It's just the Taylor series using only the first derivative, so we can use this approximation.
# Now we plot the figure
# First, suppose this is the P(x). x is the yield
fx <- expression(10/(1+x)^1+10/(1+x)^2+10/(1+x)^3+10/(1+x)^4+10/(1+x)^5+1010/(1+x)^6)
x<- seq(0.01,1,by=0.0001)
plot(x, eval(fx),type="l")
x<-0.5
P<-eval(fx)
x<- seq(0.01,1,by=0.0001)
y<-rep(0.5, length(x))
change<-seq(-0.49,0.5,by=0.0001)
lines(x,P+approximate(fx,y,change),col="red")
# X2.a
(price <- 5/(1+0.04)^1 + 5/(1+0.0425)^2 + 5/(1+0.0475)^3 + 5/(1+0.049)^4 + 105/(1+0.05)^5)
fy <- function(y){
price -( 5/(1+y)^1 + 5/(1+y)^2 + 5/(1+y)^3 + 5/(1+y)^4 + 105/(1+y)^5)
}
fy2 <- function(y){
(fy(y))^2
}
# To get the solution, we only need to optimize the function fy2
optimize(fy2,c(0.000001,1))$minimum
# Therefore, the yield is 0.04963675
# And we could check it by ploting it
plot(fy,xlim = c(0,1),ylim = c(-20,80))
abline(h = 0)
abline(v = optimize(fy2,c(0.000001,1))$minimum)
# X2.b
# First, calculate the new price
(price <- 5/(1+0.0425)^1 + 5/(1+0.045)^2 + 5/(1+0.05)^3 + 5/(1+0.0515)^4 + 105/(1+0.0525)^5)
# The new price should be 99.08189
optimize(fy2,c(0.000001,1))$minimum
# The new YTM is 0.05211581
approximate(expression(5/(1+x)^1 + 5/(1+x)^2 + 5/(1+x)^3 + 5/(1+x)^4 + 105/(1+x)^5), 0.04963675, 0.05211581 - 0.04963675)
# The unrealised profit/loss is  -1.068128
## X1. Approximation of bond price
# Taylor expansion
TaylorDiff<-function(f,n,x,s) {
k<-D(as.expression(body(f)),'x')
p<-f(x)
for (j in 1:n) {
p<-p+eval(k,list(x))*s^(j)*(1/factorial(j))
k<-D(k,"x")
}
return(p-f(x+s))
}
f <- function(x)
100 * exp(-30*x)
# Price-yield relationship
func <- function(y){
100 * exp(-30*y)
}
k <- -3000 * exp(-30*0.05)
P0 <- 100 * exp(-30*0.05)
func1 <- function(y){
k * (y-0.05) + P0
}
curve(func, xlim = c(0,0.1), main = "Price-yield relationship",
xlab = "Yield to Maturity y (in years)", ylab = "Bond Price P")
curve(func1, xlim = c(0,0.1), col='blue', lwd=1.5, lty=2, add = TRUE)
## X2. Bisection method
p <- 5/(1+0.04) + 5/(1+0.0425)^2 + 5/(1+0.0475)^3 + 5/(1+0.049)^4 + (5+100)/(1+0.05)^5
f <- function(y){
5/(1+y) + 5/(1+y)^2 + 5/(1+y)^3 + 5/(1+y)^4 + (5+100)/(1+y)^5 - p
}
curve(f, xlim = c(-0.05,0.1), col = 'blue', lwd=1.5, lty=2)
abline(h=0)
abline(v=0)
bisection <- function(f, a, b, n = 1000, tol = 1e-7) {
if (!(f(a)  * f(b) < 0)) {
stop('signs of f(a) and f(b) differ')
}
for (i in 1:n) {
c <- (a + b) / 2
if ((f(c) == 0) || ((b - a) / 2) < tol) {
return(c)
}
ifelse(sign(f(c)) == sign(f(a)),
a <- c,
b <- c)
}
}
# Calculate the zero point
bisection(f, 0, 0.1)
# Zero-coupon curve increases uniformly by 0.25%
p2 <- 5/(1+0.0425) + 5/(1+0.045)^2 + 5/(1+0.05)^3 + 5/(1+0.0515)^4 + (5+100)/(1+0.0525)^5
f2 <- function(y){
5/(1+y) + 5/(1+y)^2 + 5/(1+y)^3 + 5/(1+y)^4 + (5+100)/(1+y)^5 - p2
}
bisection(f2, 0, 0.1)
## X1. Approximation of bond price
# Taylor expansion
TaylorDiff<-function(f,n,x,s) {
k<-D(as.expression(body(f)),'x')
p<-f(x)
for (j in 1:n) {
p<-p+eval(k,list(x))*s^(j)*(1/factorial(j))
k<-D(k,"x")
}
return(p-f(x+s))
}
f <- function(x)
100 * exp(-30*x)
# Price-yield relationship
func <- function(y){
100 * exp(-30*y)
}
k <- -3000 * exp(-30*0.05)
P0 <- 100 * exp(-30*0.05)
func1 <- function(y){
k * (y-0.05) + P0
}
curve(func, xlim = c(0,0.1), main = "Price-yield relationship",
xlab = "Yield to Maturity y (in years)", ylab = "Bond Price P")
curve(func1, xlim = c(0,0.1), col='blue', lwd=1.5, lty=2, add = TRUE)
## X2. Bisection method
p <- 5/(1+0.04) + 5/(1+0.0425)^2 + 5/(1+0.0475)^3 + 5/(1+0.049)^4 + (5+100)/(1+0.05)^5
f <- function(y){
5/(1+y) + 5/(1+y)^2 + 5/(1+y)^3 + 5/(1+y)^4 + (5+100)/(1+y)^5 - p
}
curve(f, xlim = c(-0.05,0.1), col = 'blue', lwd=1.5, lty=2)
abline(h=0)
abline(v=0)
bisection <- function(f, a, b, n = 1000, tol = 1e-7) {
if (!(f(a)  * f(b) < 0)) {
stop('signs of f(a) and f(b) differ')
}
for (i in 1:n) {
c <- (a + b) / 2
if ((f(c) == 0) || ((b - a) / 2) < tol) {
return(c)
}
ifelse(sign(f(c)) == sign(f(a)),
a <- c,
b <- c)
}
}
# Calculate the zero point
bisection(f, 0, 0.1)
# Zero-coupon curve increases uniformly by 0.25%
p2 <- 5/(1+0.0425) + 5/(1+0.045)^2 + 5/(1+0.05)^3 + 5/(1+0.0515)^4 + (5+100)/(1+0.0525)^5
f2 <- function(y){
5/(1+y) + 5/(1+y)^2 + 5/(1+y)^3 + 5/(1+y)^4 + (5+100)/(1+y)^5 - p2
}
bisection(f2, 0, 0.1)
library(R2WinBUGS)
#The directory of the WinBUGS
WinBUGS_path = "C:/Users/s1155063404/Downloads/WinBUGS14/"
#Working directory
working_dir = "C:/Users/s1155063404/Desktop/Projects/brazilian-ecommerce-dataset/StatisticalAnalysis"
setwd(working_dir)
dataset = read_csv("./dataset.csv")
#Standardize the observations for modeling
standardize <- function(x){
mean_x = mean(x)
sig_x = sqrt(var(x))
if (sig_x > 0){
return((x - mean_x) / sig_x)
}
else {
return(x)
}
}
dataset$size = standardize(dataset$size)
dataset$order_products_value = standardize(dataset$order_products_value)
dataset$order_freight_value = standardize(dataset$order_freight_value)
dataset$distance = standardize(dataset$distance)
#Generate data for model: base
K = nrow(order)
n_clust = length(unique(dataset$cluster))
Y = dataset$delivery_time
X = as.matrix(dataset[,c(1,2,3)])
Z = dataset$distance
i = dataset$cluster
mu_b = rep(0, 3)
tau_b = diag(rep(0.0001, 3))
data = list(K=K, n_clust=n_clust, Y=Y, X=X, Z=Z, mu_b=mu_b, tau_b=tau_b, i=i)
bugs.data(data, dir="../WinBUGS_code/", data.file = "data_base.txt")
library(readr)
#-----------------------------------------------------------------------------
library(R2WinBUGS)
library(readr)
#The directory of the WinBUGS
WinBUGS_path = "C:/Users/s1155063404/Downloads/WinBUGS14/"
#Working directory
working_dir = "C:/Users/s1155063404/Desktop/Projects/brazilian-ecommerce-dataset/StatisticalAnalysis"
setwd(working_dir)
dataset = read_csv("./dataset.csv")
#Standardize the observations for modeling
standardize <- function(x){
mean_x = mean(x)
sig_x = sqrt(var(x))
if (sig_x > 0){
return((x - mean_x) / sig_x)
}
else {
return(x)
}
}
dataset$size = standardize(dataset$size)
dataset$order_products_value = standardize(dataset$order_products_value)
dataset$order_freight_value = standardize(dataset$order_freight_value)
dataset$distance = standardize(dataset$distance)
#Generate data for model: base
K = nrow(order)
n_clust = length(unique(dataset$cluster))
Y = dataset$delivery_time
X = as.matrix(dataset[,c(1,2,3)])
Z = dataset$distance
i = dataset$cluster
mu_b = rep(0, 3)
tau_b = diag(rep(0.0001, 3))
data = list(K=K, n_clust=n_clust, Y=Y, X=X, Z=Z, mu_b=mu_b, tau_b=tau_b, i=i)
bugs.data(data, dir="../WinBUGS_code/", data.file = "data_base.txt")
init = list(beta=rep(0,3), m1=0, m2=0, tau_a=10, tau_u=10, b=0.5)
para = c("m1", "beta", "m2", "sig_u", "sig_a", "b")
sim = bugs(data="data_base.txt", inits=list(init),
parameters.to.save=para,
model.file="base.txt",
n.chains=1, n.iter=1000,
bugs.directory = WinBUGS_path,
working.directory="../WinBUGS_code/")
sim = bugs(data="data_base.txt", inits=list(init),
parameters.to.save=para,
model.file="base.txt",
n.chains=1, n.iter=1000,
bugs.directory = WinBUGS_path,
working.directory="../WinBUGS_code/")
save(sim, file="sim_base.RData")
