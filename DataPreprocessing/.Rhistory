return(b)
}
for (i in 1:10000) {
c = (a + b) / 2
if (f(a)*f(c)>0) {
a = c
} else if
(f(b)*f(c)>0) {
b = c
}
if ((f(c) == 0) || (abs(b-a)) < tol) {
return(c)
}
}
print("notfind")
}
# find the root (i.e. 1/(1+y))
func = function(x) {
y = -100 + 5*x + 5*x^(2) +5*x^(3) +5*x^(4) +105*x^(5)
return(y)
}
bisection(func,0.2,1.3)
#find the new y
func2 = function(x) {
y = -100 + 4*x + 4.25*x^(2) +4.5*x^(3) +4.75*x^(4) +105*x^(5)
return(y)
}
bisection(func2,0.2,1.3)
#B1
func0 = function(x){
y = 6/(1+x)+6/(1+x)^2+6/(1+x)^3+6/(1+x)^4+6/(1+x)^5+6/(1+x)^6+6/(1+x)^7+6/(1+x)^8+6/(1+x)^9+106/(1+x)^10
return(y)
}
x = seq(0,0.1,0.002)
x2 = c(0.04, 0.0401)
s = (func0(x2[1])-func0(x2[2]))/(x2[1]-x2[2]) #slope of tangent
plot(x,func0(x),type = "l", ylab = "bond price($)", xlab = "yield to maturity in years")
lines(c(0.04,0.06),c(func0(0.06),func0(0.06)), type="l", col="blue", lwd=2, pch=19)
lines(c(0.04,0.04),c(func0(0.04),func0(0.06)), type="l", col="blue", lwd=2, pch=19)
lines(c(0.04,0.06),c(func0(0.04),func0(0.06)), type="l", col="blue", lwd=2, pch=19)
plot(x,func0(x),type = "l", ylab = "bond price($)", xlab = "yield to maturity in years")
abline(func0(x2[1])-x2[1]*s,s, col = "red")
points(0.04,func0(0.04),col="blue")
#--------------------------
#B2
#Bisection method:
bisection <- function (f, a, b, tol = 1e-7)
{
if ((f(a) > 0) && (f(b) > 0)) {
stop('same signs')
} else if ((f(a) < 0) && (f(b) < 0)) {
stop('same signs')
} else if (f(a)==0) {
return(a)
} else if (f(b)==0) {
return(b)
}
for (i in 1:10000) {
c = (a + b) / 2
if (f(a)*f(c)>0) {
a = c
} else if
(f(b)*f(c)>0) {
b = c
}
if ((f(c) == 0) || (abs(b-a)) < tol) {
return(c)
}
}
print("notfind")
}
# find the root (i.e. 1/(1+y))
func = function(x) {
y = -100 + 5*x + 5*x^(2) +5*x^(3) +5*x^(4) +105*x^(5)
return(y)
}
bisection(func,0.2,1.1)
#find the new y
func2 = function(x) {
y = -100 + 4*x + 4.25*x^(2) +4.5*x^(3) +4.75*x^(4) +105*x^(5)
return(y)
}
bisection(func2,0.2,1.1)
# Let it be a 10-year bond, 6% coupon with annual coupon payment.
# Left hand side = p(y)-p(y+delta y). let delta y = 0.001
fy<-function(y){(6*(1-1/(1+y)^10))/y-6*(1-1/(1+y+0.001)^10)/(y+0.001)}
curve(expr=fy,from=0,to=1)
# Right hand side = -D(delta y)
fy1<-function(y){0.001*(10*y/(1+y)^11+1-1/(1+y)^10)/y^2}
curve(expr=fx1,from=0,to=1,add=TRUE)
# Let it be a 10-year bond, 6% coupon with annual coupon payment.
# Left hand side = p(y)-p(y+delta y). let delta y = 0.001
fy<-function(y){(6*(1-1/(1+y)^10))/y-6*(1-1/(1+y+0.001)^10)/(y+0.001)}
curve(expr=fy,from=0,to=1)
# Right hand side = -D(delta y)
fy1<-function(y){0.001*(10*y/(1+y)^11+1-1/(1+y)^10)/y^2}
curve(expr=fy1,from=0,to=1,add=TRUE)
# Let it be a 10-year bond, 6% coupon with annual coupon payment.
# Left hand side = p(y+delta y). let delta y = 0.001
fy<-function(y){6*(1-1/(1+y+0.001)^10)/(y+0.001)}
curve(expr=fy,from=0,to=1)
# Right hand side = P(y){1-D*(delta y)}
fy1<-function(y){(6*(1-1/(1+y)^10))/y+0.001*(10*y/(1+y)^11+1-1/(1+y)^10)/y^2}
curve(expr=fy1,from=0,to=1,add=TRUE)
# let t = 1/(1+y)
ft = function(t){5*t+5*t^2+5*t^3+5*t^4+105*t^5-100.1580}
ft1 = function(t){5+10*t+15*t^2+20*t^3+525*t^4}
# we choose the starting y = 1 ---> t = 0.5
t = 0.5
while (abs(ft(t))>0.0000000001){t=t-ft(t)/ft1(t)}
# we can have y = 1/t - 1
1/t-1
pv<-5/(1+0.04)+5/(1+0.0425)^2+5/(1+0.0475)^3+5/(1+0.049)^4+105/(1+0.05)^5
fy<-function(y){
5/(1+y)+5/(1+y)^2+5/(1+y)^3+5/(1+y)^4+105/(1+y)^5-pv
}
curve(fy,xlim=c(0,0.1),col='red',lty=2)
abline(h=0)
bisection<-function(fy,a,b,n=1000,tol=1e-7){
if(!fy(a)*fy(b)<0){
stop('signs of fy(a) and fy(b) are different')
}
for (i in 1:n){
c<-(a+b)/2
if((fy(c)==0)||((b-a)/2)<tol){
return(c)
}
ifelse(sign(fy(c))==sign(fy(a)),
a<-c,
b<-c)
}
}
print(bisection(fy,0.04,0.06))
# Create cash flow vector
cf <- c(-100.16, 5, 5, 5, 5, 105)
# Create bond valuation function
bval <- function(i, cf,
t=seq(along = cf))
sum(cf / (1 + i)^t)
# Create ytm() function using uniroot
ytm <- function(cf) {
uniroot(bval, c(0, 1), cf = cf)$root
}
#1a
#f,n,x,s need to be initialized
TaylorDiff<-function(f,n,x,s) {
k<-D(as.expression(body(f)),'x')
p<-f(x)
for (j in 1:n) {
p<-p+eval(k,list(x))*s^(j)*(1/factorial(j))
k<-D(k,"x")
}
return(p-f(x+s))
}
#1b	example of sin(x) approximated at x0=1
f<-function(x) sin(x)
x0<-1
k<-D(as.expression(body(f)),'x')
k2<-D(k,'x')
plot(f,xlim=c(-5,5),ylim=c(-5,5),type='l',col='red')
app1<-function(x) f(x0)+eval(k,list(x=x0))*(x-x0)
app2<-function(x) app1(x)+0.5*eval(k2,list(x=x0))*(x-x0)^2
plot(app1,xlim=c(-5,5),ylim=c(-5,5),type='l',col='blue',add=T)
plot(app2,xlim=c(-5,5),ylim=c(-5,5),type='l',col='violet',add=T)
f<-function(x) 5/x*(1-1/(1+x)^5)+100/(1+x)^5-100.158
plot(f,type='l',col='red')
#bisection
bisection<-function(f,a,b,n=1000,err=0.000001) {
if(f(a)*f(b)>0)
stop('signs of f(a) and f(b) are same')
else {
for (i in 1:n) {
c<-(a+b)/2
if(f(c)==0||(b-a)<err)
return(c)
else if(f(c)*f(a)>0)
a<-c
else
b<-c
}
print('too many times!')
}
}
bisection(f,0.001,1)
#newton
k<-D(as.expression(body(f)),'x')
x0<-0.3
x<-x0
for(j in 1:1000) {
x<-x-f(x)/eval(k,list(x))
}
print(x)
# RMSC2001 Assignment 2
# Li Keqi
# 1155107825
# X1.a
approximate<-function(func,x,change){
return (eval(D(func,"x"))*change+(eval(D(D(func,"x"),"x"))*change^2)/2+(eval(D(D(D(func,"x"),"x"),"x"))*change^3)/6)
}
# X1.b
# It's just the Taylor series using only the first derivative, so we can use this approximation.
# Now we plot the figure
# First, suppose this is the P(x). x is the yield
fx <- expression(10/(1+x)^1+10/(1+x)^2+10/(1+x)^3+10/(1+x)^4+10/(1+x)^5+1010/(1+x)^6)
x<- seq(0.01,1,by=0.0001)
plot(x, eval(fx),type="l")
x<-0.5
P<-eval(fx)
x<- seq(0.01,1,by=0.0001)
y<-rep(0.5, length(x))
change<-seq(-0.49,0.5,by=0.0001)
lines(x,P+approximate(fx,y,change),col="red")
# X2.a
(price <- 5/(1+0.04)^1 + 5/(1+0.0425)^2 + 5/(1+0.0475)^3 + 5/(1+0.049)^4 + 105/(1+0.05)^5)
fy <- function(y){
price -( 5/(1+y)^1 + 5/(1+y)^2 + 5/(1+y)^3 + 5/(1+y)^4 + 105/(1+y)^5)
}
fy2 <- function(y){
(fy(y))^2
}
# To get the solution, we only need to optimize the function fy2
optimize(fy2,c(0.000001,1))$minimum
# Therefore, the yield is 0.04963675
# And we could check it by ploting it
plot(fy,xlim = c(0,1),ylim = c(-20,80))
abline(h = 0)
abline(v = optimize(fy2,c(0.000001,1))$minimum)
# X2.b
# First, calculate the new price
(price <- 5/(1+0.0425)^1 + 5/(1+0.045)^2 + 5/(1+0.05)^3 + 5/(1+0.0515)^4 + 105/(1+0.0525)^5)
# The new price should be 99.08189
optimize(fy2,c(0.000001,1))$minimum
# The new YTM is 0.05211581
approximate(expression(5/(1+x)^1 + 5/(1+x)^2 + 5/(1+x)^3 + 5/(1+x)^4 + 105/(1+x)^5), 0.04963675, 0.05211581 - 0.04963675)
# The unrealised profit/loss is  -1.068128
# RMSC2001 Assignment 2
# Li Keqi
# 1155107825
# X1.a
approximate<-function(func,x,change){
return (eval(D(func,"x"))*change+(eval(D(D(func,"x"),"x"))*change^2)/2+(eval(D(D(D(func,"x"),"x"),"x"))*change^3)/6)
}
# X1.b
# It's just the Taylor series using only the first derivative, so we can use this approximation.
# Now we plot the figure
# First, suppose this is the P(x). x is the yield
fx <- expression(10/(1+x)^1+10/(1+x)^2+10/(1+x)^3+10/(1+x)^4+10/(1+x)^5+1010/(1+x)^6)
x<- seq(0.01,1,by=0.0001)
plot(x, eval(fx),type="l")
x<-0.5
P<-eval(fx)
x<- seq(0.01,1,by=0.0001)
y<-rep(0.5, length(x))
change<-seq(-0.49,0.5,by=0.0001)
lines(x,P+approximate(fx,y,change),col="red")
# X2.a
(price <- 5/(1+0.04)^1 + 5/(1+0.0425)^2 + 5/(1+0.0475)^3 + 5/(1+0.049)^4 + 105/(1+0.05)^5)
fy <- function(y){
price -( 5/(1+y)^1 + 5/(1+y)^2 + 5/(1+y)^3 + 5/(1+y)^4 + 105/(1+y)^5)
}
fy2 <- function(y){
(fy(y))^2
}
# To get the solution, we only need to optimize the function fy2
optimize(fy2,c(0.000001,1))$minimum
# Therefore, the yield is 0.04963675
# And we could check it by ploting it
plot(fy,xlim = c(0,1),ylim = c(-20,80))
abline(h = 0)
abline(v = optimize(fy2,c(0.000001,1))$minimum)
# X2.b
# First, calculate the new price
(price <- 5/(1+0.0425)^1 + 5/(1+0.045)^2 + 5/(1+0.05)^3 + 5/(1+0.0515)^4 + 105/(1+0.0525)^5)
# The new price should be 99.08189
optimize(fy2,c(0.000001,1))$minimum
# The new YTM is 0.05211581
approximate(expression(5/(1+x)^1 + 5/(1+x)^2 + 5/(1+x)^3 + 5/(1+x)^4 + 105/(1+x)^5), 0.04963675, 0.05211581 - 0.04963675)
# The unrealised profit/loss is  -1.068128
## X1. Approximation of bond price
# Taylor expansion
TaylorDiff<-function(f,n,x,s) {
k<-D(as.expression(body(f)),'x')
p<-f(x)
for (j in 1:n) {
p<-p+eval(k,list(x))*s^(j)*(1/factorial(j))
k<-D(k,"x")
}
return(p-f(x+s))
}
f <- function(x)
100 * exp(-30*x)
# Price-yield relationship
func <- function(y){
100 * exp(-30*y)
}
k <- -3000 * exp(-30*0.05)
P0 <- 100 * exp(-30*0.05)
func1 <- function(y){
k * (y-0.05) + P0
}
curve(func, xlim = c(0,0.1), main = "Price-yield relationship",
xlab = "Yield to Maturity y (in years)", ylab = "Bond Price P")
curve(func1, xlim = c(0,0.1), col='blue', lwd=1.5, lty=2, add = TRUE)
## X2. Bisection method
p <- 5/(1+0.04) + 5/(1+0.0425)^2 + 5/(1+0.0475)^3 + 5/(1+0.049)^4 + (5+100)/(1+0.05)^5
f <- function(y){
5/(1+y) + 5/(1+y)^2 + 5/(1+y)^3 + 5/(1+y)^4 + (5+100)/(1+y)^5 - p
}
curve(f, xlim = c(-0.05,0.1), col = 'blue', lwd=1.5, lty=2)
abline(h=0)
abline(v=0)
bisection <- function(f, a, b, n = 1000, tol = 1e-7) {
if (!(f(a)  * f(b) < 0)) {
stop('signs of f(a) and f(b) differ')
}
for (i in 1:n) {
c <- (a + b) / 2
if ((f(c) == 0) || ((b - a) / 2) < tol) {
return(c)
}
ifelse(sign(f(c)) == sign(f(a)),
a <- c,
b <- c)
}
}
# Calculate the zero point
bisection(f, 0, 0.1)
# Zero-coupon curve increases uniformly by 0.25%
p2 <- 5/(1+0.0425) + 5/(1+0.045)^2 + 5/(1+0.05)^3 + 5/(1+0.0515)^4 + (5+100)/(1+0.0525)^5
f2 <- function(y){
5/(1+y) + 5/(1+y)^2 + 5/(1+y)^3 + 5/(1+y)^4 + (5+100)/(1+y)^5 - p2
}
bisection(f2, 0, 0.1)
## X1. Approximation of bond price
# Taylor expansion
TaylorDiff<-function(f,n,x,s) {
k<-D(as.expression(body(f)),'x')
p<-f(x)
for (j in 1:n) {
p<-p+eval(k,list(x))*s^(j)*(1/factorial(j))
k<-D(k,"x")
}
return(p-f(x+s))
}
f <- function(x)
100 * exp(-30*x)
# Price-yield relationship
func <- function(y){
100 * exp(-30*y)
}
k <- -3000 * exp(-30*0.05)
P0 <- 100 * exp(-30*0.05)
func1 <- function(y){
k * (y-0.05) + P0
}
curve(func, xlim = c(0,0.1), main = "Price-yield relationship",
xlab = "Yield to Maturity y (in years)", ylab = "Bond Price P")
curve(func1, xlim = c(0,0.1), col='blue', lwd=1.5, lty=2, add = TRUE)
## X2. Bisection method
p <- 5/(1+0.04) + 5/(1+0.0425)^2 + 5/(1+0.0475)^3 + 5/(1+0.049)^4 + (5+100)/(1+0.05)^5
f <- function(y){
5/(1+y) + 5/(1+y)^2 + 5/(1+y)^3 + 5/(1+y)^4 + (5+100)/(1+y)^5 - p
}
curve(f, xlim = c(-0.05,0.1), col = 'blue', lwd=1.5, lty=2)
abline(h=0)
abline(v=0)
bisection <- function(f, a, b, n = 1000, tol = 1e-7) {
if (!(f(a)  * f(b) < 0)) {
stop('signs of f(a) and f(b) differ')
}
for (i in 1:n) {
c <- (a + b) / 2
if ((f(c) == 0) || ((b - a) / 2) < tol) {
return(c)
}
ifelse(sign(f(c)) == sign(f(a)),
a <- c,
b <- c)
}
}
# Calculate the zero point
bisection(f, 0, 0.1)
# Zero-coupon curve increases uniformly by 0.25%
p2 <- 5/(1+0.0425) + 5/(1+0.045)^2 + 5/(1+0.05)^3 + 5/(1+0.0515)^4 + (5+100)/(1+0.0525)^5
f2 <- function(y){
5/(1+y) + 5/(1+y)^2 + 5/(1+y)^3 + 5/(1+y)^4 + (5+100)/(1+y)^5 - p2
}
bisection(f2, 0, 0.1)
library(dplyr)
library(readr)
setwd("C:/Users/s1155063404/Desktop/Projects/brazilian-ecommerce-dataset/DataPreprocessing")
#Load dataset
raw_geolocation = read_csv("../CleanedDataset/corrected_geolocation.csv")
raw_order = read_csv("../CleanedDataset/order.csv")
raw_product_measure = read_csv("../CleanedDataset/product_measure.csv")
raw_seller = read_csv("../CleanedDataset/seller.csv")
order = raw_order %>%
select(order_id, product_id, order_products_value, order_freight_value, product_category_name,
customer_city, customer_state, customer_zip_code_prefix,
order_purchase_timestamp, order_aproved_at, order_delivered_customer_date)
#Convert the raw data into useful features:
#Delivery time
order = order %>%
mutate(delivery_time = as.numeric(order_delivered_customer_date - order_purchase_timestamp, units="days"),
order_purchase_timestamp = NULL,
order_aproved_at = NULL,
order_delivered_customer_date = NULL) %>%
filter(! is.na(delivery_time))
#product_size & weights
product = raw_product_measure %>%
mutate(size = product_length_cm * product_height_cm * product_width_cm,
weight = product_weight_g) %>%
select(product_id, size, weight)
order = order %>%
left_join(product, by="product_id") %>%
filter(! is.na(size)) %>%
mutate(product_category_name = NULL)
#------------------------------------------------------------------------------------------------------
#Compute distance between seller and customer based on (zip_code, city)
#------------------------------------------------------------------------------------------------------
#Compute the geographical center of each (zip_code, city)
geolocation = raw_geolocation %>%
group_by(zip_code_prefix, city) %>%
summarize(lat = mean(lat),
lng = mean(lng))
#Incorporate the location information
order = order %>%
mutate(customer_city = tolower(customer_city),
customer_zip_code_prefix = as.integer(customer_zip_code_prefix)) %>%
left_join(geolocation %>%
ungroup() %>%
mutate(customer_city = tolower(city),
customer_zip_code_prefix = zip_code_prefix,
customer_lat = lat,
customer_lng = lng) %>%
select(starts_with("customer")), by=c("customer_zip_code_prefix", "customer_city")) %>%
filter(!is.na(customer_lat))
order = order %>%
left_join(raw_seller, by=c("order_id", "product_id")) %>%
mutate(seller_city = tolower(seller_city),
seller_zip_code_prefix = as.integer(seller_zip_code_prefix)) %>%
left_join(geolocation %>%
ungroup() %>%
mutate(seller_city = tolower(city),
seller_zip_code_prefix = zip_code_prefix,
seller_lat = lat,
seller_lng = lng) %>%
select(starts_with("seller")), by=c("seller_zip_code_prefix", "seller_city")) %>%
filter(!is.na(seller_lat))
#Convert location to distance on Earth; Using Spherical Law of Cosines to compute distance
distance <- function(lat1, lng1, lat2, lng2){
R = 6371 #Radius of Earth in km
dang = sin(lat1) * sin(lat2) + cos(lat1) * cos(lat2) * cos(lng2 - lng1)
return(R * acos(pmax(pmin(dang, 1), -1)))
}
ang2rad <- function(ang){
return(ang * pi / 180)
}
order = order %>%
mutate(distance = distance(ang2rad(customer_lat), ang2rad(customer_lng),
ang2rad(seller_lat), ang2rad(seller_lng)),
customer_lat = NULL,
customer_lng = NULL,
seller_lat = NULL,
seller_lng = NULL)
library(lme4)
#--------------------------------------------------------------------------
#Hypothesis: There is correlation for observations for the customers within same city
#Modelling: GLM vs GLMM (which assumes correlation for observations within city)
#Conclusion: GLMM is statistically more appropriate based on lrtest and AIC score
#--------------------------------------------------------------------------
library(lme4)
# require(lmtest)
#Form the cluster index: for each customer_city:customer_state
cluster = order %>%
group_by(customer_city, customer_state) %>%
summarize(cluster = n())
cluster$cluster = seq(1, nrow(cluster))
tmp = order %>%
left_join(cluster, by=c("customer_city", "customer_state"))
#Standardize the observations for modeling
standardize <- function(x){
mean_x = mean(x)
sig_x = sqrt(var(x))
if (sig_x > 0){
return((x - mean_x) / sig_x)
}
else {
return(x)
}
}
order_model = data.frame(
size = standardize(tmp$size),
order_products_value = standardize(tmp$order_products_value),
order_freight_value = standardize(tmp$order_freight_value),
distance = standardize(tmp$distance),
cluster = as.factor(tmp$cluster),
delivery_time = tmp$delivery_time
)
fit = glmer(delivery_time ~ size + order_products_value + order_freight_value +
distance + (1 + distance | cluster),
data = order_model, family=Gamma(link="log"))
base = glm(delivery_time ~ size + order_products_value + order_freight_value + distance,
data = order_model, family=Gamma(link="log"))
summary(fit)
summary(base)
lrtest(base, fit)
#Insample score
#Naive estimate:
mean(abs(order_model$delivery_time - median(order_model$delivery_time)))
#Fitted result:
mean(abs(exp(predict(fit)) - order_model$delivery_time))
